<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Voice of The Body | Lareina</title>
<meta name=keywords content><meta name=description content=" Invited by the Wuzhen Theater Festival ‚ÄúThe Voice of The Body‚Äù"><meta name=author content><link rel=canonical href=https://lareinali.art/choreography/voice-of--body/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://lareinali.art/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lareinali.art/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lareinali.art/favicon-32x32.png><link rel=apple-touch-icon href=https://lareinali.art/apple-touch-icon.png><link rel=mask-icon href=https://lareinali.art/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://lareinali.art/choreography/voice-of--body/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="The Voice of The Body"><meta property="og:description" content=" Invited by the Wuzhen Theater Festival ‚ÄúThe Voice of The Body‚Äù"><meta property="og:type" content="article"><meta property="og:url" content="https://lareinali.art/choreography/voice-of--body/"><meta property="og:image" content="https://lareinali.art/projects/Voice-of%20-body/covere8.jpg"><meta property="article:section" content="choreography"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lareinali.art/projects/Voice-of%20-body/covere8.jpg"><meta name=twitter:title content="The Voice of The Body"><meta name=twitter:description content=" Invited by the Wuzhen Theater Festival ‚ÄúThe Voice of The Body‚Äù"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Choreographies","item":"https://lareinali.art/choreography/"},{"@type":"ListItem","position":2,"name":"The Voice of The Body","item":"https://lareinali.art/choreography/voice-of--body/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Voice of The Body","name":"The Voice of The Body","description":" Invited by the Wuzhen Theater Festival ‚ÄúThe Voice of The Body‚Äù","keywords":[],"articleBody":"üîó YouTube\nIn this piece, I converted the body movements of dancers into voice through the application of posture sensors based on the Arduino platform, integrating these movements with parameters such as pitch, frequency, volume, and timbre in Max/MSP, This explores the connection between music and body movements (dance) and makes innovative attempts.\nBasic Parameters and Data Classification of the WT901CM Attitude Sensor\nWT901CM is a nine-axis digital posture sensor produced by WitMotion. The sensor integrates a high-precision gyroscope, accelerometer, and geomagnetic sensor. From an algorithmic perspective, it internally integrates an attitude solver and utilizes a Kalman filter algorithm, allowing it to accurately output the module‚Äôs current posture in dynamic environments. The static accuracy of posture measurement is 0.05 degrees, while the dynamic accuracy is 0.1 degrees. It is compatible with 3.3V/5V embedded systems and supports a TTL interface. The maximum data output rate is 200Hz.\nThe sensor‚Äôs appearance is shown in the diagram below, where the module‚Äôs axes are divided into the X-axis, Y-axis, and Z-axis, with the Z-axis being perpendicular to the module. The direction of axial rotation follows the right-hand rule: if the thumb of the right hand points along the axis, the direction in which the fingers curl while making a fist indicates the direction of rotation around that axis.\n![en](/projects/Voice-of -body/fig 2.jpeg)\nBefore using the sensor, it needs to be connected to a computer to adjust the parameters via the host computer program. In the host computer interface, you can view the sensor‚Äôs data integration.\n![en](/projects/Voice-of -body/fig 1.jpg)\nEach data transmission package contains the following five groups of information: time, acceleration in the three axes, angular velocity in the three axes, temperature, and angles in the three axes. The data shown in the UI interface, such as port status, magnetic field strength, latitude and longitude, quaternion, GPS data, and satellite data, are not available because this sensor does not support those functions. The data displayed on the host computer interface are the processed results from the program. When connecting the sensor to an Arduino development board, the data output is in raw form, unprocessed. The data format is as shown below.\nfig 4\nIt‚Äôs important to note that the raw data are sent in hexadecimal, not in the ASCII code commonly used in serial communication. Each data point is transmitted in two parts: the low byte and the high byte. The two hexadecimal characters in the raw data are combined to form one data point, which is a signed short type of data. The conversion method is as follows:\nAssuming Data is the actual data we need, DataH is the high byte, and DataL is the low byte, the formula is: Data = ((short)DataH ¬´ 8) | DataL. Here, DataH must first be converted into a signed short type of data, then shifted eight bits forward to form a 16-bit signed binary number. Finally, it is converted into a signed decimal number, which is the data we can intuitively understand. Below are the formulas for calculating acceleration, angles, and angular velocity:\nAcceleration calculation formulas: ax = ((AxH ¬´ 8) | AxL) / 32768 * 16g (g is gravitational acceleration, which can be taken as 9.8 m/s¬≤) ay = ((AyH ¬´ 8) | AyL) / 32768 * 16g (g is gravitational acceleration, which can be taken as 9.8 m/s¬≤) az = ((AzH ¬´ 8) | AzL) / 32768 * 16g (g is gravitational acceleration, which can be taken as 9.8 m/s¬≤)\nChecksum: Sum = 0x55 + 0x51 + AxH + AxL + AyH + AyL + AzH + AzL + TH + TL\nAngle calculation formulas: Roll (x-axis) = ((RollH ¬´ 8) | RollL) / 32768 * 180¬∞ Pitch (y-axis) = ((PitchH ¬´ 8) | PitchL) / 32768 * 180¬∞ Yaw (z-axis) = ((YawH ¬´ 8) | YawL) / 32768 * 180¬∞\nChecksum: Sum = 0x55 + 0x53 + RollH + RollL + PitchH + PitchL + YawH + YawL + TH + TL\nAngular velocity calculation formulas: wx = ((wxH ¬´ 8) | wxL) / 32768 * 2000¬∞/s wy = ((wyH ¬´ 8) | wyL) / 32768 * 2000¬∞/s wz = ((wzH ¬´ 8) | wzL) / 32768 * 2000¬∞/s\nChecksum: Sum = 0x55 + 0x52 + wxH + wxL + wyH + wyL + wzH + wzL + TH + TL\nIn practical use, this calculation process will be completed on the Arduino platform.\nArduino Platform Program Logic The Arduino platform is an open-source hardware and software development platform that can be used for IoT, embedded electronics, and various interactive projects. It is primarily based on microcontroller development boards and associated software tools, offering strong scalability and broad applicability. Moreover, the Arduino platform is highly compatible with the Max/MSP visual programming platform, which is one of the main reasons I chose this platform.\nAfter understanding the basic parameters and data classification of the WT901CM attitude sensor, the next step is to direct the raw data to the Arduino development board. Considering factors such as cost and latency, it is necessary to decode and process the data on the Arduino platform before sending it to the Max/MSP system. The Arduino platform programming code is shown below.\nfig 5\nTo successfully unpack the raw data from the posture sensor in the code, it is necessary to integrate a third-party library for the sensor. The detailed operation process is not elaborated upon in the paper. As shown in Figure 5, I only send a total of nine sets of data to the PC: ‚Äúthree-axis angles,‚Äù ‚Äúthree-axis angular velocities,‚Äù and ‚Äúthree-axis accelerations,‚Äù based on the practical needs of the project. The hardware device will eventually send data packets to the PC at a bit rate of 115200 and a frequency of 10Hz, with each data packet containing the aforementioned nine sets of data.\nData Flow Processing in Max/MSP After connecting the Arduino platform to the PC, data transmission between Arduino and Max will occur via serial communication. However, after activating serial communication, a preliminary data conversion process is needed within Max; otherwise, the output data will be unusable.\nFig 6\nIn Max, the ‚Äúserial‚Äù object is used to activate serial communication. The letter ‚Äúd‚Äù in the figure‚Äôs suffix represents the connection port COM 4, and 115200 represents the corresponding baud rate. These must match the sensor settings; otherwise, the data cannot be received properly.\nThe ‚Äúserial‚Äù object requires the ‚Äúmetro‚Äù object to repeatedly send ‚Äúbang‚Äù signals to transmit the received data. The ‚Äúserial‚Äù object sends a string composed entirely of integer values converted from ASCII format, including the start and stop codes 10 and 13. After removing the start and stop codes using the ‚Äúselect‚Äù object, the ‚Äúzl group‚Äù object is used to bundle the data, which is then processed using the ‚Äúitoa‚Äù function object to restore the integer string into the data we need.\nAfter obtaining the correctly formatted data, it is necessary to continue unpacking and processing the data.\nfig 7\nThis step is aimed at standardizing the data format, converting conventional signed values such as angles and acceleration into a data flow that better aligns with the dancer‚Äôs movement patterns. This also includes zero-point calibration for the sensor. During performances, the starting point can be calibrated according to the stage direction to ensure that the angles triggering the sound during the performance are consistent with those during rehearsals.\nFinally, after completing all the processing, the dancer‚Äôs movements can be digitized and visualized within the Max/MSP system.\n","wordCount":"1241","inLanguage":"en","image":"https://lareinali.art/projects/Voice-of%20-body/covere8.jpg","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://lareinali.art/choreography/voice-of--body/"},"publisher":{"@type":"Organization","name":"Lareina","logo":{"@type":"ImageObject","url":"https://lareinali.art/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lareinali.art/ accesskey=h title="Lareina (Alt + H)">Lareina</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lareinali.art/ title=Home><span>Home</span></a></li><li><a href=https://lareinali.art/blog title=Blog><span>Blog</span></a></li><li><a href=https://lareinali.art/choreography title=Choreography><span>Choreography</span></a></li><li><a href=https://lareinali.art/experience title=Internships><span>Internships</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lareinali.art/>Home</a>&nbsp;¬ª&nbsp;<a href=https://lareinali.art/choreography/>Choreographies</a></div><h1 class="post-title entry-hint-parent">The Voice of The Body</h1><div class=post-description>Invited by the Wuzhen Theater Festival ‚ÄúThe Voice of The Body‚Äù</div><div class=post-meta></div></header><figure class=entry-cover><img loading=eager src=https://lareinali.art/projects/Voice-of%20-body/covere8.jpg alt></figure><div class=post-content><p>üîó <a href="https://www.youtube.com/watch?v=dirqSoZnUyE">YouTube</a></p><ul><li><p>In this piece, I converted the body movements of dancers into voice through the application of posture sensors based on the Arduino platform, integrating these movements with parameters such as pitch, frequency, volume, and timbre in Max/MSP, This explores the connection between music and body movements (dance) and makes innovative attempts.</p></li><li><p>Basic Parameters and Data Classification of the WT901CM Attitude Sensor</p></li></ul><p>WT901CM is a nine-axis digital posture sensor produced by WitMotion. The sensor integrates a high-precision gyroscope, accelerometer, and geomagnetic sensor. From an algorithmic perspective, it internally integrates an attitude solver and utilizes a Kalman filter algorithm, allowing it to accurately output the module&rsquo;s current posture in dynamic environments. The static accuracy of posture measurement is 0.05 degrees, while the dynamic accuracy is 0.1 degrees. It is compatible with 3.3V/5V embedded systems and supports a TTL interface. The maximum data output rate is 200Hz.</p><p>The sensor‚Äôs appearance is shown in the diagram below, where the module&rsquo;s axes are divided into the X-axis, Y-axis, and Z-axis, with the Z-axis being perpendicular to the module. The direction of axial rotation follows the right-hand rule: if the thumb of the right hand points along the axis, the direction in which the fingers curl while making a fist indicates the direction of rotation around that axis.</p><p>![en](/projects/Voice-of -body/fig 2.jpeg)</p><p>Before using the sensor, it needs to be connected to a computer to adjust the parameters via the host computer program. In the host computer interface, you can view the sensor&rsquo;s data integration.</p><p>![en](/projects/Voice-of -body/fig 1.jpg)</p><p>Each data transmission package contains the following five groups of information: time, acceleration in the three axes, angular velocity in the three axes, temperature, and angles in the three axes. The data shown in the UI interface, such as port status, magnetic field strength, latitude and longitude, quaternion, GPS data, and satellite data, are not available because this sensor does not support those functions. The data displayed on the host computer interface are the processed results from the program. When connecting the sensor to an Arduino development board, the data output is in raw form, unprocessed. The data format is as shown below.</p><p>fig 4</p><p>It‚Äôs important to note that the raw data are sent in hexadecimal, not in the ASCII code commonly used in serial communication. Each data point is transmitted in two parts: the low byte and the high byte. The two hexadecimal characters in the raw data are combined to form one data point, which is a signed short type of data. The conversion method is as follows:</p><p>Assuming Data is the actual data we need, DataH is the high byte, and DataL is the low byte, the formula is:
Data = ((short)DataH &#171; 8) | DataL.
Here, DataH must first be converted into a signed short type of data, then shifted eight bits forward to form a 16-bit signed binary number. Finally, it is converted into a signed decimal number, which is the data we can intuitively understand. Below are the formulas for calculating acceleration, angles, and angular velocity:</p><p>Acceleration calculation formulas:
ax = ((AxH &#171; 8) | AxL) / 32768 * 16g (g is gravitational acceleration, which can be taken as 9.8 m/s¬≤)
ay = ((AyH &#171; 8) | AyL) / 32768 * 16g (g is gravitational acceleration, which can be taken as 9.8 m/s¬≤)
az = ((AzH &#171; 8) | AzL) / 32768 * 16g (g is gravitational acceleration, which can be taken as 9.8 m/s¬≤)</p><p>Checksum:
Sum = 0x55 + 0x51 + AxH + AxL + AyH + AyL + AzH + AzL + TH + TL</p><p>Angle calculation formulas:
Roll (x-axis) = ((RollH &#171; 8) | RollL) / 32768 * 180¬∞
Pitch (y-axis) = ((PitchH &#171; 8) | PitchL) / 32768 * 180¬∞
Yaw (z-axis) = ((YawH &#171; 8) | YawL) / 32768 * 180¬∞</p><p>Checksum:
Sum = 0x55 + 0x53 + RollH + RollL + PitchH + PitchL + YawH + YawL + TH + TL</p><p>Angular velocity calculation formulas:
wx = ((wxH &#171; 8) | wxL) / 32768 * 2000¬∞/s
wy = ((wyH &#171; 8) | wyL) / 32768 * 2000¬∞/s
wz = ((wzH &#171; 8) | wzL) / 32768 * 2000¬∞/s</p><p>Checksum:
Sum = 0x55 + 0x52 + wxH + wxL + wyH + wyL + wzH + wzL + TH + TL</p><p>In practical use, this calculation process will be completed on the Arduino platform.</p><ul><li>Arduino Platform Program Logic</li></ul><p>The Arduino platform is an open-source hardware and software development platform that can be used for IoT, embedded electronics, and various interactive projects. It is primarily based on microcontroller development boards and associated software tools, offering strong scalability and broad applicability. Moreover, the Arduino platform is highly compatible with the Max/MSP visual programming platform, which is one of the main reasons I chose this platform.</p><p>After understanding the basic parameters and data classification of the WT901CM attitude sensor, the next step is to direct the raw data to the Arduino development board. Considering factors such as cost and latency, it is necessary to decode and process the data on the Arduino platform before sending it to the Max/MSP system. The Arduino platform programming code is shown below.</p><p>fig 5</p><p>To successfully unpack the raw data from the posture sensor in the code, it is necessary to integrate a third-party library for the sensor. The detailed operation process is not elaborated upon in the paper. As shown in Figure 5, I only send a total of nine sets of data to the PC: &ldquo;three-axis angles,&rdquo; &ldquo;three-axis angular velocities,&rdquo; and &ldquo;three-axis accelerations,&rdquo; based on the practical needs of the project. The hardware device will eventually send data packets to the PC at a bit rate of 115200 and a frequency of 10Hz, with each data packet containing the aforementioned nine sets of data.</p><ul><li>Data Flow Processing in Max/MSP</li></ul><p>After connecting the Arduino platform to the PC, data transmission between Arduino and Max will occur via serial communication. However, after activating serial communication, a preliminary data conversion process is needed within Max; otherwise, the output data will be unusable.</p><p>Fig 6</p><p>In Max, the &ldquo;serial&rdquo; object is used to activate serial communication. The letter &ldquo;d&rdquo; in the figure&rsquo;s suffix represents the connection port COM 4, and 115200 represents the corresponding baud rate. These must match the sensor settings; otherwise, the data cannot be received properly.</p><p>The &ldquo;serial&rdquo; object requires the &ldquo;metro&rdquo; object to repeatedly send &ldquo;bang&rdquo; signals to transmit the received data. The &ldquo;serial&rdquo; object sends a string composed entirely of integer values converted from ASCII format, including the start and stop codes 10 and 13. After removing the start and stop codes using the &ldquo;select&rdquo; object, the &ldquo;zl group&rdquo; object is used to bundle the data, which is then processed using the &ldquo;itoa&rdquo; function object to restore the integer string into the data we need.</p><p>After obtaining the correctly formatted data, it is necessary to continue unpacking and processing the data.</p><p>fig 7</p><p>This step is aimed at standardizing the data format, converting conventional signed values such as angles and acceleration into a data flow that better aligns with the dancer&rsquo;s movement patterns. This also includes zero-point calibration for the sensor. During performances, the starting point can be calibrated according to the stage direction to ensure that the angles triggering the sound during the performance are consistent with those during rehearsals.</p><p>Finally, after completing all the processing, the dancer&rsquo;s movements can be digitized and visualized within the Max/MSP system.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://lareinali.art/>Lareina</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>